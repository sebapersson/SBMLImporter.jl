# Picewise statements are parsed later to events, and are initially kept as piecewise.
# Julia does not have a root_n function, so SBMLImporter provides its own nrooth
# rateOf is a SBML function. This expression is replaced later, as reactions rates
# have to be parsed for this stage.
# nallowed_args=Int64[] is any number of args
const SBML_FN_INFO = Dict("*" => (fn = "*", nallowed_args = [0, 1, 2]),
                          "+" => (fn = "+", nallowed_args = [0, 1, 2]),
                          "-" => (fn = "-", nallowed_args = [1, 2]),
                          "/" => (fn = "/", nallowed_args = [2]),
                          "power" => (fn = "^", nallowed_args = [2]),
                          "quotient" => (fn = "div", nallowed_args = [2]),
                          "root" => (fn = "sqrt", nallowed_args = [2]),
                          "piecewise" => (fn = "piecewise", nallowed_args = [2, 3, 4]),
                          "lt" => (fn = "lt", nallowed_args = [2]),
                          "gt" => (fn = "gt", nallowed_args = [2]),
                          "leq" => (fn = "leq", nallowed_args = [2]),
                          "geq" => (fn = "geq", nallowed_args = [2]),
                          "eq" => (fn = "eq", nallowed_args = [2]),
                          "neq" => (fn = "neq", nallowed_args = [2]),
                          "and" => (fn = "and", nallowed_args = [0, 1, 2]),
                          "or" => (fn = "or", nallowed_args = [0, 1, 2]),
                          "if" => (fn = "if", nallowed_args = [0, 1, 2]),
                          "xor" => (fn = "xor", nallowed_args = [0, 1, 2]),
                          "not" => (fn = "not", nallowed_args = [1]),
                          "exp" => (fn = "exp", nallowed_args = [1]),
                          "abs" => (fn = "abs", nallowed_args = [1]),
                          "log" => (fn = "log", nallowed_args = [1, 2]),
                          "ln" => (fn = "log", nallowed_args = [1]),
                          "log2" => (fn = "log2", nallowed_args = [1]),
                          "log10" => (fn = "log10", nallowed_args = [1]),
                          "sin" => (fn = "sin", nallowed_args = [1]),
                          "cos" => (fn = "cos", nallowed_args = [1]),
                          "tan" => (fn = "tan", nallowed_args = [1]),
                          "sec" => (fn = "sec", nallowed_args = [1]),
                          "csc" => (fn = "csc", nallowed_args = [1]),
                          "cot" => (fn = "cot", nallowed_args = [1]),
                          "sinh" => (fn = "sinh", nallowed_args = [1]),
                          "cosh" => (fn = "cosh", nallowed_args = [1]),
                          "tanh" => (fn = "tanh", nallowed_args = [1]),
                          "sech" => (fn = "sech", nallowed_args = [1]),
                          "csch" => (fn = "csch", nallowed_args = [1]),
                          "coth" => (fn = "coth", nallowed_args = [1]),
                          "arcsin" => (fn = "asin", nallowed_args = [1]),
                          "arccos" => (fn = "acos", nallowed_args = [1]),
                          "arctan" => (fn = "atan", nallowed_args = [1]),
                          "arcsec" => (fn = "asec", nallowed_args = [1]),
                          "arccsc" => (fn = "acsc", nallowed_args = [1]),
                          "arccot" => (fn = "acot", nallowed_args = [1]),
                          "arcsinh" => (fn = "asinh", nallowed_args = [1]),
                          "arccosh" => (fn = "acosh", nallowed_args = [1]),
                          "arctanh" => (fn = "atanh", nallowed_args = [1]),
                          "arcsech" => (fn = "asech", nallowed_args = [1]),
                          "arccoth" => (fn = "acoth", nallowed_args = [1]),
                          "arccsch" => (fn = "acsch", nallowed_args = [1]),
                          "ceiling" => (fn = "ceil", nallowed_args = [1]),
                          "floor" => (fn = "floor", nallowed_args = [1]),
                          "rateOf" => (fn = "rateOf", nallowed_args = [1]),
                          "min" => (fn = "min", nallowed_args = [1, 2, 3, 4, 5]),
                          "max" => (fn = "max", nallowed_args = [1, 2, 3, 4, 5]),
                          "rem" => (fn = "rem", nallowed_args = Int64[2]),
                          "factorial" => (fn = "SpecialFunctions.gamma",
                                          nallowed_args = [1]),
                          "delay" => (fn = "delay", nallowed_args = Int64[]),
                          "implies" => (fn = "implies", nallowed_args = Int64[]))

const _F1 = FunctionSBML(["__x__", "__cond__", "__y__"], "ifelse(__cond__, __x__, __y__)")
const _F2 = FunctionSBML(["__x__", "__cond__"], "ifelse(__cond__, __x__, 0)")
const _F3 = FunctionSBML(["__x__", "__cond__", "__y__", "__z__"],
                         "ifelse(__cond__, __x__, __y__)")
const _F4 = FunctionSBML(["__x__", "__y__"], "ifelse(__x__, 1, 0) + ifelse(__y__, 1, 0)")
const _G1 = FunctionSBML(["__x__", "__y__"], "ifelse(__x__, 1, 0)*ifelse(__y__, 1, 0) == 1")
const _G2 = FunctionSBML(["__x__", "__y__"], "sign(__BSUM__(__x__, __y__)) == 1")
const _G3 = FunctionSBML(["__x__", "__y__"],
                         "-(__BSUM__(__x__, __y__))^2 + 2*(__BSUM__(__x__, __y__)) == 1")
const PIECEWISE_FN = Dict("gt" => FunctionSBML(["__x__", "__y__"], "__x__ > __y__"),
                          "lt" => FunctionSBML(["__x__", "__y__"], "__x__ < __y__"),
                          "geq" => FunctionSBML(["__x__", "__y__"], "__x__ >= __y__"),
                          "leq" => FunctionSBML(["__x__", "__y__"], "__x__ <= __y__"),
                          "eq" => FunctionSBML(["__x__", "__y__"], "__x__ == __y__"),
                          "neq" => FunctionSBML(["__x__", "__y__"], "__x__ != __y__"),
                          "not" => FunctionSBML(["__x__"], "!__x__"),
                          "and" => _G1,
                          "or" => _G2,
                          "if" => _G2,
                          "xor" => _G3,
                          "and0" => FunctionSBML(String[], "true"),
                          "or0" => FunctionSBML(String[], "false"),
                          "xor0" => FunctionSBML(String[], "false"),
                          "and1" => FunctionSBML(["__x__"], "__x__"),
                          "or1" => FunctionSBML(["__x__"], "__x__"),
                          "xor1" => FunctionSBML(["__x__"], "__x__"),
                          "piecewise" => _F1,
                          "piecewise2" => _F2,
                          "piecewise4" => _F3,
                          "__BSUM__" => _F4)
const SBML_FN_NAMES::Vector{String} = getfield.(values(SBMLImporter.SBML_FN_INFO), :fn)
const PIECEWISE_FN_NAMES::Vector{String} = collect(keys(PIECEWISE_FN))
