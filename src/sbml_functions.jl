# Picewise statements are parsed later to events, and are initially kept as piecewise.
# Julia does not have a root_n function, so SBMLImporter provides its own nrooth
# rateOf is a SBML function. This expression is replaced later, as reactions rates
# have to be parsed for this stage.
# nallowed_args=Int64[] is any number of args
const SBML_FN_INFO = Dict("*" => (fn = "*", nallowed_args = [0, 1, 2]),
    "+" => (fn = "+", nallowed_args = [0, 1, 2]),
    "-" => (fn = "-", nallowed_args = [1, 2]),
    "/" => (fn = "/", nallowed_args = [2]),
    "power" => (fn = "^", nallowed_args = [2]),
    "quotient" => (fn = "div", nallowed_args = [2]),
    "root" => (fn = "sqrt", nallowed_args = [2]),
    "piecewise" => (fn = "piecewise", nallowed_args = [2, 3, 4, 5]),
    "lt" => (fn = "lt", nallowed_args = [2]),
    "gt" => (fn = "gt", nallowed_args = [2]),
    "leq" => (fn = "leq", nallowed_args = [2]),
    "geq" => (fn = "geq", nallowed_args = [2]),
    "eq" => (fn = "eq", nallowed_args = [2]),
    "neq" => (fn = "neq", nallowed_args = [2]),
    "and" => (fn = "and", nallowed_args = [0, 1, 2]),
    "or" => (fn = "or", nallowed_args = [0, 1, 2]),
    "if" => (fn = "if", nallowed_args = [0, 1, 2]),
    "xor" => (fn = "xor", nallowed_args = [0, 1, 2]),
    "not" => (fn = "not", nallowed_args = [1]),
    "exp" => (fn = "exp", nallowed_args = [1]),
    "abs" => (fn = "abs", nallowed_args = [1]),
    "log" => (fn = "log", nallowed_args = [1, 2]),
    "ln" => (fn = "log", nallowed_args = [1]),
    "log2" => (fn = "log2", nallowed_args = [1]),
    "log10" => (fn = "log10", nallowed_args = [1]),
    "sin" => (fn = "sin", nallowed_args = [1]),
    "cos" => (fn = "cos", nallowed_args = [1]),
    "tan" => (fn = "tan", nallowed_args = [1]),
    "sec" => (fn = "sec", nallowed_args = [1]),
    "csc" => (fn = "csc", nallowed_args = [1]),
    "cot" => (fn = "cot", nallowed_args = [1]),
    "sinh" => (fn = "sinh", nallowed_args = [1]),
    "cosh" => (fn = "cosh", nallowed_args = [1]),
    "tanh" => (fn = "tanh", nallowed_args = [1]),
    "sech" => (fn = "sech", nallowed_args = [1]),
    "csch" => (fn = "csch", nallowed_args = [1]),
    "coth" => (fn = "coth", nallowed_args = [1]),
    "arcsin" => (fn = "asin", nallowed_args = [1]),
    "arccos" => (fn = "acos", nallowed_args = [1]),
    "arctan" => (fn = "atan", nallowed_args = [1]),
    "arcsec" => (fn = "asec", nallowed_args = [1]),
    "arccsc" => (fn = "acsc", nallowed_args = [1]),
    "arccot" => (fn = "acot", nallowed_args = [1]),
    "arcsinh" => (fn = "asinh", nallowed_args = [1]),
    "arccosh" => (fn = "acosh", nallowed_args = [1]),
    "arctanh" => (fn = "atanh", nallowed_args = [1]),
    "arcsech" => (fn = "asech", nallowed_args = [1]),
    "arccoth" => (fn = "acoth", nallowed_args = [1]),
    "arccsch" => (fn = "acsch", nallowed_args = [1]),
    "ceiling" => (fn = "ceil", nallowed_args = [1]),
    "floor" => (fn = "floor", nallowed_args = [1]),
    "rateOf" => (fn = "rateOf", nallowed_args = [1]),
    "min" => (fn = "min", nallowed_args = [1, 2, 3, 4, 5]),
    "max" => (fn = "max", nallowed_args = [1, 2, 3, 4, 5]),
    "rem" => (fn = "rem", nallowed_args = Int64[2]),
    "factorial" => (fn = "SpecialFunctions.gamma",
        nallowed_args = [1]),
    "delay" => (fn = "delay", nallowed_args = Int64[]),
    "implies" => (fn = "implies", nallowed_args = Int64[]))

const _F1 = FunctionSBML(["__x__", "__cond__", "__y__"], "ifelse(__cond__, __x__, __y__)")
const _F2 = FunctionSBML(["__x__", "__cond__"], "ifelse(__cond__, __x__, 0)")
const _F3 = FunctionSBML(["__x__", "__cond__", "__y__", "__z__"],
    "ifelse(__cond__, __x__, __y__)")
const _F4 = FunctionSBML(["__x__", "__cond1__", "__y__", "__cond2__", "__z__"],
    "ifelse(__cond1__, __x__, ifelse(__cond2__, __y__, __z__))")

const _F5 = FunctionSBML(["__x__", "__y__"], "ifelse(__x__, 1, 0) + ifelse(__y__, 1, 0)")
const _G1 = FunctionSBML(["__x__", "__y__"], "ifelse(__x__, 1, 0)*ifelse(__y__, 1, 0) == 1")
const _G2 = FunctionSBML(["__x__", "__y__"], "sign(__BSUM__(__x__, __y__)) == 1")
const _G3 = FunctionSBML(["__x__", "__y__"],
    "-(__BSUM__(__x__, __y__))^2 + 2*(__BSUM__(__x__, __y__)) == 1")
const PIECEWISE_FN = Dict("gt" => FunctionSBML(["__x__", "__y__"], "__x__ > __y__"),
    "lt" => FunctionSBML(["__x__", "__y__"], "__x__ < __y__"),
    "geq" => FunctionSBML(["__x__", "__y__"], "__x__ >= __y__"),
    "leq" => FunctionSBML(["__x__", "__y__"], "__x__ <= __y__"),
    "eq" => FunctionSBML(["__x__", "__y__"], "__x__ == __y__"),
    "neq" => FunctionSBML(["__x__", "__y__"], "__x__ != __y__"),
    "not" => FunctionSBML(["__x__"], "!__x__"),
    "and" => _G1,
    "or" => _G2,
    "if" => _G2,
    "xor" => _G3,
    "and0" => FunctionSBML(String[], "true"),
    "or0" => FunctionSBML(String[], "false"),
    "xor0" => FunctionSBML(String[], "false"),
    "and1" => FunctionSBML(["__x__"], "__x__"),
    "or1" => FunctionSBML(["__x__"], "__x__"),
    "xor1" => FunctionSBML(["__x__"], "__x__"),
    "piecewise" => _F1,
    "piecewise2" => _F2,
    "piecewise4" => _F3,
    "piecewise5" => _F4,
    "__BSUM__" => _F5)
const SBML_FN_NAMES::Vector{String} = getfield.(values(SBML_FN_INFO), :fn)
const PIECEWISE_FN_NAMES::Vector{String} = collect(keys(PIECEWISE_FN))
